/**************************************************************************/
cat /proc/bus/pci/devices
每一项分别代表什么意思？

0d00    177d0050        a9          dfffc00c
   0        d800      000c                 0
   0           0  fc300000              4000
   0     4000000         0                 0
   0       10000     Icore

    0d00: 总线0d, 8 bit, 设备号0, 5 bit, 功能号0, bit3.
          由此生成设备对应文件/proc/bus/pci/0d(bus)/0(device).0(function)
          0d -t x1 00.0 第十字节开始的双字节表示设备的类型
177d0050: 177d  vendorid, 0050 deviceid.
      a9: irq.
dfffc00c: bar0
       0: unused
    d800: bar1
    000c: unused
       0: unused
       0: unused
       0: unused
fc300000: size0
    4000: unused
       0: size1
 4000000:
       0:
       0:
       0:
   10000:

    1300:
177d0050: 177d  vendorid, 0050 deviceid.
      b1: irq
c5ffc00c: bar0
       0: unused
c000000c: bar1
       0: unused
       0: unused
       0: unused
c4000000: unused
    4000: size0
       0: unused
 4000000: size1
       0:
       0:
       0:
   10000:


0800
177d0092 : vendorid, deviceid
92       : irq
fbffc00c : bar0
0        : unused
f400000c : bar1
0        : unused
0        : unused
0        : unused
fe8f0000 : unused
4000     : size0
0        : unused
4000000  : size1
0        :
0        :
0        :
10000    :
Octeon






cd /proc/bus/pci/13/
od  -x 00.0
                  octeon_cfg1 = 0X01470010
0000000 177d 0050 0147 0010 0008 0b30 0010 0000
0000020 c00c c5ff 0000 0000 000c c000 0000 0000
0000040 000c 0000 0000 0000 0000 0000 177d 0001
0000060 0000 0000 0040 0000 0000 0000 0103 0000
0000100 5001 0003 0000 0000 0000 0000 0000 0000
0000120 7005 0080 0000 0000 0000 0000 0000 0000
0000140 0000 0000 0000 0000 0000 0000 0000 0000
0000160 0010 0002 8701 0000 581f 0000 6c81 0003
0000200 0000 1041 0000 0000 0000 0000 0000 0000
0000220 0000 0000 0010 0000 0000 0000 0000 0000
0000240 0000 0000 0000 0000 0000 0000 0000 0000
*
0000400 0001 0001 0000 0000 0000 0010 2030 0006
0000420 2000 0000 2000 0000 00a0 0000 0000 0000
0000440 0000 0000 0000 0000 0000 0000 0000 0000
*
0003400 0049 00db ffff ffff 0004 0700 8000 1b80
0003420 0120 000f 0000 0000 03aa 0002 0500 0000
0003440 0000 0000 0000 0000 f111 03f1 0010 0800
0003460 4020 0000 4004 0000 301f 0000 0000 0000
0003500 000f 0000 0000 0000 3080 4042 8004 0040
0003520 0000 0040 0000 0000 0000 0000 0000 0000
0003540 0000 0000 0000 0000 0000 0000 0000 0000
*
0003640 0000 0000 0000 0000 014b 0029 0038 000e
0003660 0168 0046 0000 0000 0000 0000 0000 0000
0003700 0000 0000 0000 0000 0000 0000 0000 0000
*
0004000 0000 0000 0000 0000 0000 0000 0800 0000
0004020 0000 0000 0000 0000 0000 0000 0000 0000
*
0010000

/**************************************************************************/
cat /proc/interrupts
为什么中断只出现在第一个核上?
Linux 内核常常在第一个 CPU 上处理中断,
作为一个使 cache 局部性最大化的方法

/**************************************************************************/
cat /proc/stat
intr 174152179 172918068 17 0 3 3 0 5 0 1 0 0 0 220 0 0 518303 0
         total         0  1 2 3 4
/**************************************************************************/
init_module
{
...
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
    ret = pci_module_init(&icore_pci_driver);
#else
    ret = pci_register_driver(&icore_pci_driver);
#endif
...
    icore_init_poll_thread
...
    register_chrdev
}

基础: interrupt
    request_irq什么时候调用?
    从模块的初始化函数中安装中断处理不是个好主意,
    特别当你的设备不共享中断. 因为中断线数目是有限的,
    你可以轻易使你的系统中设备数多于中断数.
    如果一个模块在初始化时请求一个 IRQ,
    它就阻止了任何其他的驱动使用这个中断.

    调用 request_irq 的正确位置是当设备第一次打开时

pcie mode config
rc mode: root complex
ep mode: endpoint

